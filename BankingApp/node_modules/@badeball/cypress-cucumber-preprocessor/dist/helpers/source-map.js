"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.retrieveSourceMapURL = retrieveSourceMapURL;
exports.createTraceMap = createTraceMap;
exports.cachedCreateTraceMap = cachedCreateTraceMap;
exports.maybeRetrievePositionFromSourceMap = maybeRetrievePositionFromSourceMap;
const trace_mapping_1 = require("@jridgewell/trace-mapping");
const base64_js_1 = require("base64-js");
const error_stack_parser_1 = __importDefault(require("error-stack-parser"));
let isSourceMapWarned = false;
function sourceMapWarn(message) {
    if (isSourceMapWarned) {
        return;
    }
    console.warn("cypress-cucumber-preprocessor: " + message);
    isSourceMapWarned = true;
}
const cache = new Map();
/**
 * Taken from https://github.com/evanw/node-source-map-support/blob/v0.5.21/source-map-support.js#L148-L177.
 */
function retrieveSourceMapURL(source) {
    let fileData;
    const xhr = new XMLHttpRequest();
    xhr.open("GET", source, /** async */ false);
    xhr.send(null);
    const { readyState, status } = xhr;
    if (readyState === 4 && status === 200) {
        fileData = xhr.responseText;
    }
    else {
        sourceMapWarn(`Unable to retrieve source map (readyState = ${readyState}, status = ${status})`);
        return;
    }
    const re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/gm;
    // Keep executing the search to find the *last* sourceMappingURL to avoid
    // picking up sourceMappingURLs from comments, strings, etc.
    let lastMatch, match;
    while ((match = re.exec(fileData)))
        lastMatch = match;
    if (!lastMatch) {
        sourceMapWarn("Unable to find source mapping URL within the response. Are you bundling with source maps enabled?");
        return;
    }
    return lastMatch[1];
}
function createTraceMap(source) {
    const sourceMappingURL = retrieveSourceMapURL(source);
    if (!sourceMappingURL) {
        return;
    }
    const rawSourceMap = JSON.parse(new TextDecoder().decode((0, base64_js_1.toByteArray)(sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1))));
    return new trace_mapping_1.TraceMap(rawSourceMap);
}
function cachedCreateTraceMap(source) {
    if (cache.has(source)) {
        return cache.get(source);
    }
    else {
        const result = createTraceMap(source);
        cache.set(source, result);
        return result;
    }
}
function maybeRetrievePositionFromSourceMap() {
    const stack = error_stack_parser_1.default.parse(new Error());
    const relevantFrame = stack[3];
    if (relevantFrame.fileName == null) {
        return;
    }
    const sourceMap = cachedCreateTraceMap(relevantFrame.fileName);
    if (!sourceMap) {
        return;
    }
    const position = (0, trace_mapping_1.originalPositionFor)(sourceMap, {
        line: relevantFrame.getLineNumber(),
        column: relevantFrame.getColumnNumber(),
    });
    if (position.source === null) {
        return;
    }
    position.source = position.source.replace(/^webpack:\/\/\//, "");
    return {
        line: position.line,
        column: position.column,
        source: position.source,
    };
}
